(in-ns 'slimath.core)

(defmacro -make-matrix-ops
  "A op B"
 [{:keys [name op start end] :or {start 2}}]
 (cons `do (for [n (range start end)]
             `(defn ~(str-sym- \m n name)
                ~name
                [~'a ~'b]
                (-vec-op ~op ~(* n n) ~'a ~'b)))))

(defmacro -make-matrix-scalar-ops
  "A op s"
 [{:keys [name op start end] :or {start 2}}]
 (cons `do (for [n (range start end)]
             `(defn ~(str-sym- \m n name \s)
                ~name
                [~'a ~'s]
                (-vec-scalar-op ~op ~(* n n) ~'a ~'s)))))

(defmacro -make-matrix-column-lookups
 [{:keys [start end] :or {start 2}}]
 (cons `do (for [n (range start end)]
             `(defn ~(str-sym- \m n "col")
                "column lookup"
                [~'A ~'c]
                (~(str-sym- "vec" n) 
                 ~@(for [r (range n)] `(~'A (+ (* ~'c ~n) ~r))))))))

(defmacro -make-matrix-row-lookups
 [{:keys [start end] :or {start 2}}]
 (cons `do (for [n (range start end)]
             `(defn ~(str-sym- \m n "row")
                "row lookup"
                [~'A ~'r]
                (~(str-sym- "vec" n)
                 ~@(for [c (range n)] `(~'A (+ (* ~c ~n) ~'r))))))))

(defmacro -make-matrix-lookups 
 [{:keys [start end] :or {start 2}}]
  (cons 'do
        (for [n (range start end)]
          `(defn ~(str-sym- "m" n)
             [~'A ~'r ~'c]
             (~'A (+ (* ~'c ~n) ~'r))))))

(defmacro -make-matrix-identities 
 [{:keys [name op start end] :or {start 2}}]
  (cons `do
        (for [n (range start end)]
          `(defn ~(str-sym- "m" n "identity")
             ~(str n "x" n " identity matrix")
             []
             [~@(for [x (range n) y (range n)]
                   (if (= x y) 1 0))]))))

;; TODO - can't we use fn? here?
(defmacro -make-matrix-generator [f is-fn]
  (cons `do
        (for [n [2 3 4]]
          `(defn ~(str-sym- "m" n f)
             ~(str "Generate " n "x" n " matrix with entries generated by f")
             []
             [~@(for [x (range (* n n))] (if is-fn `(~f) f))]))))

(defmacro -make-matrix-factories 
"matrix factories take their args in row-major order"
 [{:keys [start end] :or {start 2}}]
  (cons `do
        (for [n (range start end)]
          (let [fname# (str-sym- "matrix" n)]
          `(defn ~fname# ~(str "Create an " n "x" n " matrix")
             [~@(for [r (range n) c (range n)] (str-sym- "m" r c))]
             [ ~@(for [r (range n) c (range n)] 
                                   (str-sym- "m" c r))])))))

(defmacro -make-matrix-str
 [{:keys [start end] :or {start 2}}]
 (cons `do (for [n (range start end)]
             (let [row# (str-sym- "m" n "row")]
               `(defn ~(str-sym- \m n "str")
                  "matrix to str"
                [~'A]
                (str ~@(interpose "\n" 
                                  (for [r (range n)] 
                                    `(pr-str (~row# ~'A ~r))))))))))

(defmacro -make-mmul [{:keys [start end] :or {start 2}}]
  (cons `do 
         (for [n (range start end)]
          (let [mmul# (str-sym- "m" n "mul")
                dot# (str-sym- "v" n "dot")
                row# (str-sym- "m" n "row")
                col# (str-sym- "m" n "col")]
            `(defn ~mmul#  ~(str "Multiply two " n "x" n " matrices")
               ([~'A ~'B]
                  (~(str-sym- "matrix" n) 
                   ~@(for [y (range n) x (range n)]
                       `(~dot# (~row# ~'A ~x) (~col# ~'B ~y)))))
               ([~'A ~'B & ~'xs]
                (reduce ~mmul# (~mmul# ~'A ~'B) ~'xs)))))))

(defmacro -make-matrix-transpose [{:keys [start end] :or {start 2}}]
  (cons `do (for [n (range start end)]
              (let [fname# (str-sym- "m" n "transpose")
                    factory# (str-sym- "matrix" n)]
                `(defn ~fname# "transpose the matrix" [~'A]
                   (~factory# ~@(for [y (range n) x (range n)]
                               `(~'A ~(+ (* x n) y)))))))))

(-make-matrix-factories {:end 5})
(-make-matrix-identities {:end 5})
(-make-matrix-generator rand true)

(-make-matrix-lookups {:end 5})
(-make-matrix-row-lookups {:end 5})
(-make-matrix-column-lookups {:end 5})
(-make-matrix-str {:end 5})
(-make-matrix-ops {:name "add" :op + :end 5})
(-make-matrix-ops {:name "sub" :op - :end 5})
(-make-matrix-ops {:name "mul" :op * :end 5})
(-make-matrix-ops {:name "div" :op / :end 5})
(-make-matrix-ops {:name "gt" :op > :end 5})
(-make-matrix-ops {:name "ge" :op >= :end 5})
(-make-matrix-ops {:name "lt" :op < :end 5})
(-make-matrix-ops {:name "le" :op <= :end 5})
(-make-matrix-ops {:name "compare" :op compare :end 5})
(-make-vec-reduce-ops { :prefix m :name "approx?" :rop and :mop approx? :end 5})

(-make-matrix-scalar-ops {:name "add" :op + :end 5})
(-make-matrix-scalar-ops {:name "sub" :op - :end 5})
(-make-matrix-scalar-ops {:name "mul" :op * :end 5})
(-make-matrix-scalar-ops {:name "div" :op / :end 5})

(-make-matrix-transpose {:end 5})

(-make-mmul {:end 5})

(defn mint [M] (apply vector-of :int M))
              
(defn m2det "2x2 matrix determinant" [A]
  (- (* (m2 A 0 0) (m2 A 1 1)) (* (m2 A 0 1) (m2 A 1 0))))

;; FIXME
(defn m3det "3x3 matrix determinant" [M]
  (v3dot (m3row M 0)
         (vec3 (- (* (m3 M 1 1) (m3 M 2 2)) (* (m3 M 1 2) (m3 M 2 1)))
               (- (* (m3 M 1 2) (m3 M 2 0)) (* (m3 M 2 2) (m3 M 1 0)))
               (- (* (m3 M 1 0) (m3 M 2 1)) (* (m3 M 1 1) (m3 M 2 0))))))

;; TODO - Generalised determinant for sizes > 3

(defn m2inverse [A]
  (m2muls (matrix2 (A 3) (- (A 2)) (- (A 1)) (A 0)) (/ (double (m2det A)))))

(defn m3inverse [M]
  "3x3 matrix inverse"
  (let [A (- (* (M 4) (M 8)) (* (M 7) (M 5))) 
        B (- (* (M 7) (M 2)) (* (M 1) (M 8)))
        C (- (* (M 1) (M 5)) (* (M 4) (M 2))) 
        D (- (* (M 6) (M 5)) (* (M 3) (M 8))) 
        E (- (* (M 0) (M 8)) (* (M 6) (M 2))) 
        F (- (* (M 2) (M 3)) (* (M 0) (M 5))) 
        G (- (* (M 3) (M 7)) (* (M 6) (M 4)))
        H (- (* (M 6) (M 1)) (* (M 0) (M 7)))
        K (- (* (M 0) (M 4)) (* (M 3) (M 1)))]
    (m3muls (matrix3 A D G
                     B E H
                     C F K) 
            (/ (double (m3det M))))))

(defn m4inverse [M]
  (let [t0 (* (M 10) (M 15)) t1 (* (M 14) (M 11))
        t2   (* (M 6) (M 15)) t3  (* (M 14) (M 7))
        t4   (* (M 6) (M 11)) t5 (* (M 10) (M 7))
        t6   (* (M 2) (M 15)) t7 (* (M 14) (M 3))
        t8   (* (M 2) (M 11)) t9 (* (M 10) (M 3))
        t10   (* (M 2) (M 7)) t11  (* (M 6) (M 3))
        t12   (* (M 8) (M 13)) t13  (* (M 12) (M 9))
        t14   (* (M 4) (M 13)) t15 (* (M 12) (M 5))
        t16   (* (M 4) (M 9))  t17 (* (M 8) (M 5))
        t18   (* (M 0) (M 13)) t19 (* (M 12) (M 1))
        t20   (* (M 0) (M 9))  t21 (* (M 8) (M 1))
        t22   (* (M 0) (M 5))  t23 (* (M 4) (M 1))

        B [ 
            (- (+ (* t0 (M 5)) (* t3 (M 9)) (* t4 (M 13)))
               (+ (* t1 (M 5)) (* t2 (M 9)) (* t5 (M 13))))         
            (- (+ (* t1 (M 4)) (* t2 (M 8)) (* t5 (M 12)))
               (+ (* t0 (M 4)) (* t3 (M 8)) (* t4 (M 12))))
            (- (+ (* t12 (M 7)) (* t15 (M 11)) (* t16 (M 15)))
               (+ (* t13 (M 7)) (* t14 (M 11)) (* t17 (M 15))))
            (- (+ (* t14 (M 10)) (* t17 (M 14)) (* t13 (M 6)))
               (+ (* t16 (M 14)) (* t12 (M 6)) (* t15 (M 10))))

            (- (+ (* t1 (M 1)) (* t6 (M 9)) (* t9 (M 13)))
               (+ (* t0 (M 1)) (* t7 (M 9)) (* t8 (M 13))))          
            (- (+ (* t0 (M 0)) (* t7 (M 8)) (* t8 (M 12)))
               (+ (* t1 (M 0)) (* t6 (M 8)) (* t9 (M 12))))          
            (- (+ (* t13 (M 3)) (* t18 (M 11)) (* t21 (M 15)))
               (+ (* t12 (M 3)) (* t19 (M 11)) (* t20 (M 15))))            
            (- (+ (* t20 (M 14)) (* t12 (M 2)) (* t19 (M 10)))
               (+ (* t18 (M 10)) (* t21 (M 14)) (* t13 (M 2))))

            (- (+ (* t2 (M 1)) (* t7 (M 5)) (* t10 (M 13)))
               (+ (* t3 (M 1)) (* t6 (M 5)) (* t11 (M 13))))          
            (- (+ (* t3 (M 0)) (* t6 (M 4)) (* t11 (M 12)))
               (+ (* t2 (M 0)) (* t7 (M 4)) (* t10 (M 12))))          
            (- (+ (* t14 (M 3)) (* t19 (M 7)) (* t22 (M 15)))
               (+ (* t15 (M 3)) (* t18 (M 7)) (* t23 (M 15))))
            (- (+ (* t18 (M 6)) (* t23 (M 14)) (* t15 (M 2)))
               (+ (* t22 (M 14)) (* t14 (M 2)) (* t19 (M 6))))

            (- (+ (* t5 (M 1)) (* t8 (M 5)) (* t11 (M 9)))
               (+ (* t4 (M 1)) (* t9 (M 5)) (* t10 (M 9))))
            (- (+ (* t4 (M 0)) (* t9 (M 4)) (* t10 (M 8)))
               (+ (* t5 (M 0)) (* t8 (M 4)) (* t11(M 8))))
            (- (+ (* t17 (M 3)) (* t20 (M 7)) (* t23 (M 11)))
               (+ (* t16 (M 3)) (* t21 (M 7)) (* t22 (M 11))))
            (- (+ (* t22 (M 10)) (* t16 (M 2)) (* t21 (M 6)))
               (+ (* t20 (M 6)) (* t23 (M 10)) (* t17 (M 2))))]]
    (m4muls B (/ (double (v4dot(m4row M 0) (m4col B 0)))))))





